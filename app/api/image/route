// app/api/works/[id]/image/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { cookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";

// Wir nutzen Admin für Storage-Upload (SERVICE_KEY aus Server-Env)
import "@/lib/supabaseAdmin"; // nur damit TS die Datei kennt, nicht zwingend
// Falls du in lib/supabaseAdmin bereits einen Client exportierst:
import { createClient as createAdminClient } from "@supabase/supabase-js";

const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!; // muss in .env.local vorhanden sein
const admin = createAdminClient(url, serviceKey, { auth: { persistSession: false } });

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const form = await req.formData();
    const file = form.get("file") as File | null;
    if (!file) {
      return NextResponse.json({ error: "file missing" }, { status: 400 });
    }

    // Auth/Ownership check (User -> Artist -> Work)
    const cookieStore = await cookies();
    const supabase = createServerClient(url, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!, {
      cookies: {
        getAll() { return cookieStore.getAll(); },
        setAll(list) { try { list.forEach(({ name, value, options }: any) => cookieStore.set({ name, value, ...options })); } catch {} },
      },
    });

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

    const { data: artist } = await supabase
      .from("artists")
      .select("id")
      .eq("user_id", user.id)
      .maybeSingle();
    if (!artist) return NextResponse.json({ error: "Artist not found" }, { status: 404 });

    const workId = params.id;

    // Upload in Bucket "works" (öffentlicher Bucket)
    const ext = (file.name.split(".").pop() || "jpg").toLowerCase();
    const path = `${workId}/${Date.now()}.${ext}`;
    const { error: upErr } = await admin.storage.from("works").upload(path, file, {
      cacheControl: "3600",
      upsert: true,
      contentType: file.type || "image/jpeg",
    });
    if (upErr) throw upErr;

    const { data: pub } = admin.storage.from("works").getPublicUrl(path);
    const publicUrl = pub.publicUrl;

    // Work updaten – wir schreiben auf image_url (Pick-Logik kann weitere Felder lesen)
    const { error: dbErr } = await admin
      .from("works")
      .update({ image_url: publicUrl, updated_at: new Date().toISOString() })
      .eq("id", workId)
      .eq("artist_id", artist.id);
    if (dbErr) throw dbErr;

    return NextResponse.json({ ok: true, image_url: publicUrl });
  } catch (e: any) {
    console.error(e);
    return NextResponse.json({ error: e?.message ?? "Server error" }, { status: 500 });
  }
}
